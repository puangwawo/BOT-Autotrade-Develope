<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wunder Paper Trader — Single HTML</title>
  <style>
    :root{--bg:#0f1115;--panel:#171a21;--muted:#8b93a7;--text:#e6e9ef;--accent:#00e0a4;--danger:#ff5a71;--warn:#ffd166}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:var(--panel);border:1px solid #222534;border-radius:14px;padding:16px;box-shadow:0 6px 30px rgba(0,0,0,.25)}
    h1{font-size:20px;margin:0 0 8px} h2{font-size:16px;margin:0 0 10px;color:var(--muted)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .col{flex:1;min-width:260px}
    label{display:block;font-size:12px;color:var(--muted);margin:8px 0 6px}
    input,select,button{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2a2f3d;background:#0f131a;color:var(--text)}
    button{cursor:pointer;border:1px solid #2a2f3d;background:#111826;font-weight:600}
    button.primary{background:linear-gradient(90deg,#00e0a4,#17d1ff);color:#001e1a;border:none}
    button.ghost{background:#0f131a}
    button.danger{background:#2b0f14;border-color:#45161e;color:#ff9aa9}
    .grid{width:100%;border-collapse:collapse;font-size:12px}
    .grid th,.grid td{border-bottom:1px solid #242a39;padding:8px 10px;text-align:right}
    .grid th:first-child,.grid td:first-child{text-align:left}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px}
    .pill.long{background:rgba(0,224,164,.13);color:#80ffd9}
    .pill.short{background:rgba(255,90,113,.13);color:#ff9aa9}
    .stats{display:flex;gap:16px;flex-wrap:wrap}
    .stat{background:#0f131a;border:1px solid #21283a;border-radius:12px;padding:12px 14px;flex:1;min-width:120px}
    .big{font-size:18px;font-weight:700}
    canvas{width:100%;height:240px;background:#0b0e14;border:1px solid #222534;border-radius:10px}
    .footer{color:#6c748a;font-size:12px;margin-top:10px}
    .hint{color:#9aa3b2;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" style="margin-bottom:12px">
      <h1>Wunder Paper Trader (Single HTML)</h1>
      <div class="row">
        <div class="col">
          <label>Symbol (Binance)</label>
          <input id="symbol" value="PEPEUSDT"/>
        </div>
        <div class="col">
          <label>Timeframe</label>
          <select id="interval">
            <option value="1m">1m</option>
            <option value="5m">5m</option>
            <option value="15m" selected>15m</option>
            <option value="30m">30m</option>
            <option value="1h">1h</option>
          </select>
        </div>
        <div class="col">
          <label>Strategy</label>
          <select id="strategy">
            <option value="ema_rsi" selected>EMA Trend + RSI Pullback</option>
            <option value="bounce24">Bounce 24h Low (reclaim)</option>
            <option value="vol_break">Volume Spike Breakout</option>
          </select>
        </div>
        <div class="col">
          <label>Initial Balance (USDT)</label>
          <input id="initBalance" type="number" value="1000"/>
        </div>
        <div class="col">
          <label>Risk per Trade (%)</label>
          <input id="riskPct" type="number" value="5"/>
        </div>
        <div class="col">
          <label>ATR SL / TP (x)</label>
          <input id="atrMult" type="text" value="0.7,1.0,2.0"/>
          <div class="hint">Format: SLx,TP1x,TP2x — contoh 0.7,1,2</div>
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <div class="col"><button id="startBtn" class="primary">▶ Start Backtest (to latest)</button></div>
        <div class="col"><button id="liveBtn" class="ghost">⏱ Live Update (on/off)</button></div>
        <div class="col"><button id="resetBtn" class="danger">⟲ Reset</button></div>
      </div>
      <div class="footer">Data dari <b>Binance public API (spot)</b>. Ini <b>paper trading</b> — tidak mengeksekusi order asli.</div>
    </div>

    <div class="row">
      <div class="col card">
        <h2>Equity Curve</h2>
        <canvas id="equityChart"></canvas>
      </div>
      <div class="col card">
        <h2>Stats</h2>
        <div class="stats">
          <div class="stat"><div class="hint">Balance</div><div class="big" id="statBalance">-</div></div>
          <div class="stat"><div class="hint">P/L Total</div><div class="big" id="statPL">-</div></div>
          <div class="stat"><div class="hint">Win Rate</div><div class="big" id="statWR">-</div></div>
          <div class="stat"><div class="hint">Trades</div><div class="big" id="statTrades">-</div></div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <h2>Trades</h2>
      <table class="grid" id="tradesTable">
        <thead>
          <tr>
            <th>#</th><th>Time</th><th>Side</th><th>Entry</th><th>Exit</th><th>Qty</th><th>SL</th><th>TP1</th><th>TP2</th><th>P/L</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

  </div>

<script>
// ===== Utils =====
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
const fmt = (n, d=6)=> (typeof n==='number'? n.toFixed(d): n);
function median(arr){const s=[...arr].sort((a,b)=>a-b);const m=Math.floor(s.length/2);return s.length%2? s[m]:(s[m-1]+s[m])/2}
function sma(arr, p){const out=[]; let sum=0; for(let i=0;i<arr.length;i++){sum+=arr[i]; if(i>=p) sum-=arr[i-p]; out.push(i>=p-1? sum/p:null)} return out}
function ema(arr,p){const out=[]; const k=2/(p+1); let prev=null; for(let i=0;i<arr.length;i++){const v=arr[i]; if(v==null){out.push(prev); continue} prev= prev==null? v : (v - prev)*k + prev; out.push(prev)} return out}
function rsi(arr, p=14){const out=[]; let up=0, dn=0, prev=arr[0]; for(let i=1;i<arr.length;i++){const ch=arr[i]-prev; prev=arr[i]; const u=Math.max(ch,0), d=Math.max(-ch,0); if(i<=p){ up+=u; dn+=d; out.push(null); if(i===p){ let rs= (up/p) / ((dn||1e-9)/p); out[out.length-1]= 100-100/(1+rs); }} else {
  const last=out[out.length-1]; const avgUp=(( (last!=null? (100/(100-last)-1):0) * (dn||1e-9) )||0); // not used, keep classical
  up=(up*(p-1)+u)/p; dn=(dn*(p-1)+d)/p; const rs= up / (dn||1e-9); out.push(100-100/(1+rs)); }
  }
  out.unshift(null); // align length
  return out
}
function atr(high,low,close,p=14){const out=[]; let prevClose=close[0]; let trArr=[]; for(let i=0;i<close.length;i++){const h=high[i], l=low[i], c=close[i]; const tr = Math.max(h-l, Math.abs(h-prevClose), Math.abs(l-prevClose)); prevClose=c; trArr.push(tr); if(trArr.length<p){ out.push(null); } else if(trArr.length===p){ out.push(trArr.reduce((a,b)=>a+b,0)/p);} else { const prev=out[out.length-1]; out.push((prev*(p-1)+tr)/p);} }
  return out
}

// ===== Binance fetch =====
async function fetchKlines(symbol, interval, limit=1000){
  const url=`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('Binance API error');
  const raw = await res.json();
  return raw.map(r=>({
    openTime:r[0], open: +r[1], high:+r[2], low:+r[3], close:+r[4], volume:+r[5], closeTime:r[6]
  }))
}

// ===== Strategies =====
function signalsFromStrategy(candles, strat){
  const close=candles.map(c=>c.close), high=candles.map(c=>c.high), low=candles.map(c=>c.low), vol=candles.map(c=>c.volume);
  const ema50=ema(close,50), ema200=ema(close,200), rsi14=rsi(close,14), a14=atr(high,low,close,14);
  const medVol50 = sma(vol,50).map((_,i)=> median(vol.slice(Math.max(0,i-49), i+1)) );
  const dayWindow = 24*60; // minutes window, we will approximate by interval minutes
  const intervalMs = (candles[1]?.closeTime - candles[0]?.closeTime) || 60_000;
  const bars24h = Math.max(1, Math.round(24*60*60_000/intervalMs));

  const sigs = candles.map((c,i)=>({i, time:c.closeTime, type:null, reason:null, atr:a14[i]}));

  for(let i=1;i<candles.length;i++){
    const upTrend = ema50[i] != null && ema200[i] != null && ema50[i] > ema200[i];
    const dnTrend = ema50[i] != null && ema200[i] != null && ema50[i] < ema200[i];
    if(strat==='ema_rsi'){
      const crossUp = rsi14[i-1]!=null && rsi14[i-1] < 40 && rsi14[i] >= 40; // pullback ends
      const crossDn = rsi14[i-1]!=null && rsi14[i-1] > 60 && rsi14[i] <= 60;
      if(upTrend && crossUp && close[i] > ema50[i]) { sigs[i].type='long'; sigs[i].reason='EMA up + RSI↑40'; }
      if(dnTrend && crossDn && close[i] < ema50[i]) { sigs[i].type='short'; sigs[i].reason='EMA down + RSI↓60'; }
    }
    if(strat==='bounce24'){
      const from = Math.max(0, i - bars24h);
      const slice = candles.slice(from, i+1);
      const low24 = Math.min(...slice.map(x=>x.low));
      const prevCloseBelow = close[i-1] <= low24 * 1.0002; // touched/broke
      const reclaim = close[i] > low24 && close[i] > close[i-1];
      if(prevCloseBelow && reclaim) { sigs[i].type='long'; sigs[i].reason='24h Low reclaim'; }
      const high24 = Math.max(...slice.map(x=>x.high));
      const prevCloseAbove = close[i-1] >= high24 * 0.9998;
      const reject = close[i] < high24 && close[i] < close[i-1];
      if(prevCloseAbove && reject) { sigs[i].type='short'; sigs[i].reason='24h High reject'; }
    }
    if(strat==='vol_break'){
      const vOK = medVol50[i]!=null && vol[i] > medVol50[i] * 1.6;
      const bullBreak = close[i] > high[i-1] && vOK; if(bullBreak){ sigs[i].type='long'; sigs[i].reason='Break↑ + Vol spike'; }
      const bearBreak = close[i] < low[i-1] && vOK; if(bearBreak){ sigs[i].type='short'; sigs[i].reason='Break↓ + Vol spike'; }
    }
  }
  return {sigs, ema50, ema200, rsi14:a14, atr:a14};
}

// ===== Paper engine =====
function backtest(candles, sigs, cfg){
  let balance = cfg.initBalance;
  let eq = [balance];
  let trades = [];
  let pos = null; // {side, entry, qty, sl, tp1, tp2, iOpen}
  const {slx, tp1x, tp2x, riskPct} = cfg;

  for(let i=1;i<candles.length;i++){
    const cPrev=candles[i-1], c=candles[i];
    // Manage open position by SL/TP using candle extremes
    if(pos){
      if(pos.side==='long'){
        const hitSL = c.low <= pos.sl;
        const hitTP2 = c.high >= pos.tp2;
        const hitTP1 = c.high >= pos.tp1;
        if(hitSL || hitTP2 || hitTP1){
          const exit = hitSL? pos.sl : (hitTP2? pos.tp2 : pos.tp1);
          const pl = (exit - pos.entry) * pos.qty;
          balance += pl;
          trades.push({ iClose:i, iOpen:pos.iOpen, time:c.closeTime, side:pos.side, entry:pos.entry, exit, qty:pos.qty, sl:pos.sl, tp1:pos.tp1, tp2:pos.tp2, pl });
          pos=null;
        }
      } else {
        const hitSL = c.high >= pos.sl;
        const hitTP2 = c.low <= pos.tp2;
        const hitTP1 = c.low <= pos.tp1;
        if(hitSL || hitTP2 || hitTP1){
          const exit = hitSL? pos.sl : (hitTP2? pos.tp2 : pos.tp1);
          const pl = (pos.entry - exit) * pos.qty;
          balance += pl;
          trades.push({ iClose:i, iOpen:pos.iOpen, time:c.closeTime, side:pos.side, entry:pos.entry, exit, qty:pos.qty, sl:pos.sl, tp1:pos.tp1, tp2:pos.tp2, pl });
          pos=null;
        }
      }
    }

    // New signals only if flat
    if(!pos && sigs[i].type && sigs[i].atr){
      const entry = candles[i].close;
      const riskDollar = balance * (riskPct/100);
      const atr = sigs[i].atr;
      if(!atr || atr<=0) { eq.push(balance); continue; }
      if(sigs[i].type==='long'){
        const sl = entry - atr*slx; const tp1 = entry + atr*tp1x; const tp2 = entry + atr*tp2x;
        const stopDist = entry - sl; const qty = riskDollar / Math.max(stopDist, 1e-12);
        pos = {side:'long', entry, qty, sl, tp1, tp2, iOpen:i};
      } else {
        const sl = entry + atr*slx; const tp1 = entry - atr*tp1x; const tp2 = entry - atr*tp2x;
        const stopDist = sl - entry; const qty = riskDollar / Math.max(stopDist, 1e-12);
        pos = {side:'short', entry, qty, sl, tp1, tp2, iOpen:i};
      }
    }
    eq.push(balance + (pos? (pos.side==='long'? (candles[i].close-pos.entry)*pos.qty : (pos.entry-candles[i].close)*pos.qty) : 0));
  }

  // Close any open at last close
  if(pos){
    const last = candles[candles.length-1];
    const exit = last.close; const pl = (pos.side==='long')? (exit-pos.entry)*pos.qty : (pos.entry-exit)*pos.qty;
    balance += pl; trades.push({ iClose:candles.length-1, iOpen:pos.iOpen, time:last.closeTime, side:pos.side, entry:pos.entry, exit, qty:pos.qty, sl:pos.sl, tp1:pos.tp1, tp2:pos.tp2, pl }); pos=null;
  }

  const wins = trades.filter(t=>t.pl>0).length; const wr = trades.length? (wins/trades.length*100):0;
  return {balance, equity:eq, trades, winRate:wr};
}

// ===== Tiny chart (no external libs) =====
function drawChart(canvas, series){
  const ctx=canvas.getContext('2d'); const w=canvas.clientWidth, h=canvas.clientHeight; canvas.width=w*2; canvas.height=h*2; ctx.scale(2,2);
  ctx.clearRect(0,0,w,h);
  const pad=10; const min=Math.min(...series.filter(x=>isFinite(x))); const max=Math.max(...series.filter(x=>isFinite(x)));
  const xStep=(w-2*pad)/Math.max(1,series.length-1);
  ctx.lineWidth=2; ctx.beginPath();
  series.forEach((v,i)=>{
    const x=pad+i*xStep; const y = h-pad - ( (v-min)/(max-min||1) * (h-2*pad) );
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.strokeStyle='#17d1ff'; ctx.stroke();
}

// ===== UI glue =====
const els={
  symbol:document.getElementById('symbol'), interval:document.getElementById('interval'), strategy:document.getElementById('strategy'),
  initBalance:document.getElementById('initBalance'), riskPct:document.getElementById('riskPct'), atrMult:document.getElementById('atrMult'),
  startBtn:document.getElementById('startBtn'), liveBtn:document.getElementById('liveBtn'), resetBtn:document.getElementById('resetBtn'),
  statBalance:document.getElementById('statBalance'), statPL:document.getElementById('statPL'), statWR:document.getElementById('statWR'), statTrades:document.getElementById('statTrades'),
  tradesTable:document.querySelector('#tradesTable tbody'), chart:document.getElementById('equityChart')
}

let liveTimer=null, lastState=null;

function parseCfg(){
  const [slx,tp1x,tp2x] = els.atrMult.value.split(',').map(x=>+x.trim());
  return { symbol:els.symbol.value.trim().toUpperCase(), interval:els.interval.value, strategy:els.strategy.value,
    initBalance:+els.initBalance.value, riskPct:+els.riskPct.value, slx, tp1x, tp2x };
}

function render(trades, equity, balance, initBalance){
  els.tradesTable.innerHTML='';
  trades.forEach((t,idx)=>{
    const tr=document.createElement('tr');
    const time=new Date(t.time).toLocaleString();
    tr.innerHTML=`<td>${idx+1}</td><td>${time}</td><td>${t.side==='long'?'<span class="pill long">LONG</span>':'<span class="pill short">SHORT</span>'}</td>
    <td>${fmt(t.entry)}</td><td>${fmt(t.exit)}</td><td>${fmt(t.qty,4)}</td><td>${fmt(t.sl)}</td><td>${fmt(t.tp1)}</td><td>${fmt(t.tp2)}</td>
    <td style="color:${t.pl>=0?'#80ffd9':'#ff9aa9'}">${fmt(t.pl,4)}</td>`;
    els.tradesTable.appendChild(tr);
  })
  const pl = balance - initBalance; const plPct = initBalance? (pl/initBalance*100):0;
  els.statBalance.textContent = `${fmt(balance,2)} USDT`;
  els.statPL.textContent = `${fmt(pl,2)} (${fmt(plPct,2)}%)`;
  const wins = trades.filter(t=>t.pl>0).length; const wr = trades.length? (wins/trades.length*100):0;
  els.statWR.textContent = `${fmt(wr,1)}%`;
  els.statTrades.textContent = trades.length;
  drawChart(els.chart, equity);
}

async function runBacktest(live=false){
  const cfg=parseCfg();
  const candles = await fetchKlines(cfg.symbol, cfg.interval, 1000);
  const {sigs} = signalsFromStrategy(candles, cfg.strategy);
  const result = backtest(candles, sigs, cfg);
  lastState={cfg, candles, sigs, result};
  render(result.trades, result.equity, result.balance, cfg.initBalance);
  if(live){
    if(liveTimer) clearInterval(liveTimer);
    liveTimer = setInterval(async ()=>{
      try{
        const n = await fetchKlines(cfg.symbol, cfg.interval, 1000);
        const {sigs} = signalsFromStrategy(n, cfg.strategy);
        const result = backtest(n, sigs, cfg);
        lastState={cfg, candles:n, sigs, result};
        render(result.trades, result.equity, result.balance, cfg.initBalance);
      }catch(e){console.error(e)}
    }, 15_000);
  }
}

els.startBtn.onclick = ()=> runBacktest(false);
els.liveBtn.onclick = ()=>{
  if(liveTimer){ clearInterval(liveTimer); liveTimer=null; els.liveBtn.textContent='⏱ Live Update (on/off)'; }
  else { runBacktest(true); els.liveBtn.textContent='⏱ Live Update: ON'; }
}
els.resetBtn.onclick = ()=>{ if(liveTimer){clearInterval(liveTimer); liveTimer=null} lastState=null; els.tradesTable.innerHTML=''; drawChart(els.chart,[0,0]); els.statBalance.textContent='-'; els.statPL.textContent='-'; els.statWR.textContent='-'; els.statTrades.textContent='-'; }

// Auto-run first load
runBacktest(false).catch(console.error);
</script>
</body>
</html>
