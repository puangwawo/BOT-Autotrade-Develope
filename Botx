import os
import asyncio
import json
import logging
from threading import Thread
from flask import Flask, request, jsonify
from flask_cors import CORS
from binance import AsyncClient, BinanceSocketManager

# --- Konfigurasi Awal ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Kunci API (Gunakan Testnet!) ---
# Simpan kunci API Anda sebagai environment variable untuk keamanan
# Contoh: export BINANCE_API_KEY_TEST="your_api_key"
API_KEY = os.environ.get('7b159c78c7b4d2671a91495bdbbfa96ba08d1e06315a1609b46a9782d86b2d45')
API_SECRET = os.environ.get('746efa9aa4afcb9055fe38c8b58ed5f5d6bddf3a910871ce584fca5150c3b960')

if not API_KEY or not API_SECRET:
    logging.error("Pastikan Anda sudah mengatur BINANCE_API_KEY_TEST dan BINANCE_API_SECRET_TEST")
    exit()

# --- State & Settings Bot (Global) ---
bot_state = {
    "is_running": False,
    "open_position": None, # Akan berisi detail jika ada posisi, contoh: {'symbol': 'XRPUSDT', 'entry_price': 0.5, 'quantity': 100}
    "total_pl": 0.0,
    "settings": {
        "asset": "XRPUSDT",
        "timeframe": "5m",
        "take_profit": 1.5,  # dalam persen
        "stop_loss": 0.7,   # dalam persen
        "threshold": 10000, # dalam USD
        "usd_amount": 50    # jumlah USD per trade
    }
}

# --- Inisialisasi Web Server (Flask) ---
app = Flask(__name__)
CORS(app) # Mengizinkan koneksi dari UI (HTML)

@app.route('/settings', methods=['GET', 'POST'])
def handle_settings():
    if request.method == 'POST':
        new_settings = request.json
        bot_state['settings'].update(new_settings)
        logging.info(f"Pengaturan diperbarui: {bot_state['settings']}")
        return jsonify({"message": "Settings updated successfully"}), 200
    return jsonify(bot_state['settings'])

@app.route('/status', methods=['GET'])
def get_status():
    return jsonify(bot_state)

@app.route('/start', methods=['POST'])
def start_bot():
    if not bot_state['is_running']:
        bot_state['is_running'] = True
        logging.info("Bot diinstruksikan untuk START")
        return jsonify({"message": "Bot starting..."})
    return jsonify({"message": "Bot is already running"})

@app.route('/stop', methods=['POST'])
def stop_bot():
    if bot_state['is_running']:
        bot_state['is_running'] = False
        logging.info("Bot diinstruksikan untuk STOP")
        return jsonify({"message": "Bot stopping..."})
    return jsonify({"message": "Bot is already stopped"})


# --- Logika Inti Bot Trading ---
async def place_trade(client, symbol, side, quantity, price):
    """Fungsi untuk menempatkan order dan OCO (TP/SL)"""
    try:
        # 1. Tempatkan Market Order untuk masuk posisi
        logging.info(f"Menempatkan {side} order untuk {quantity} {symbol}...")
        entry_order = await client.create_order(
            symbol=symbol,
            side=side,
            type='MARKET',
            quantity=quantity
        )
        entry_price = float(entry_order['fills'][0]['price'])
        logging.info(f"Berhasil masuk posisi {symbol} di harga {entry_price}")

        bot_state['open_position'] = {'symbol': symbol, 'entry_price': entry_price, 'quantity': quantity}

        # 2. Hitung harga TP dan SL
        tp_price = round(entry_price * (1 + bot_state['settings']['take_profit'] / 100), 4)
        sl_price = round(entry_price * (1 - bot_state['settings']['stop_loss'] / 100), 4)
        
        # 3. Tempatkan OCO order untuk TP dan SL
        logging.info(f"Menempatkan OCO: TP di {tp_price}, SL di {sl_price}")
        await client.create_oco_order(
            symbol=symbol,
            side='SELL', # Selalu SELL untuk menutup posisi LONG
            quantity=quantity,
            price=tp_price, # Harga Take Profit
            stopPrice=sl_price, # Harga trigger Stop Loss
            stopLimitPrice=sl_price, # Harga eksekusi Stop Loss
            stopLimitTimeInForce='GTC'
        )
        logging.info("Order OCO (TP/SL) berhasil ditempatkan.")

    except Exception as e:
        logging.error(f"Error saat menempatkan trade: {e}")
        bot_state['open_position'] = None


async def liquidation_listener():
    """Mendengarkan stream data likuidasi dari Binance"""
    client = await AsyncClient.create(API_KEY, API_SECRET, testnet=True)
    bsm = BinanceSocketManager(client)
    
    # Stream untuk semua likuidasi di futures
    socket = bsm.futures_socket('!forceOrder@arr')

    logging.info("Mendengarkan stream likuidasi dari Binance Futures Testnet...")
    async with socket as stream:
        while True:
            res = await stream.recv()
            if res and 'data' in res:
                liq_data = res['data']['o']
                symbol = liq_data['s']
                
                # Cek jika bot running, tidak ada posisi terbuka, dan simbolnya sesuai
                if (bot_state['is_running'] and 
                    not bot_state['open_position'] and 
                    symbol == bot_state['settings']['asset']):
                    
                    price = float(liq_data['p'])
                    quantity = float(liq_data['q'])
                    liquidation_value = price * quantity

                    # Cek jika nilai likuidasi melebihi threshold
                    if liquidation_value >= bot_state['settings']['threshold']:
                        logging.info(f"--- TRIGGER LIKUIDASI TERDETEKSI ---")
                        logging.info(f"Simbol: {symbol}, Sisi: {liq_data['S']}, Nilai: ${liquidation_value:,.2f}")
                        
                        # Strategi: Jika ada likuidasi besar posisi LONG (di-SELL), kita BUY
                        if liq_data['S'] == 'SELL':
                            trade_quantity = round(bot_state['settings']['usd_amount'] / price, 3)
                            logging.info(f"Memulai trade BUY sebesar {trade_quantity} {symbol}")
                            
                            # Jalankan trade di background agar tidak memblokir listener
                            asyncio.create_task(place_trade(client, symbol, 'BUY', trade_quantity, price))

    await client.close_connection()

def run_flask_app():
    # Gunakan host 0.0.0.0 agar bisa diakses dari luar container/VM jika perlu
    app.run(host='127.0.0.1', port=5000)

if __name__ == '__main__':
    # Jalankan Flask di thread terpisah
    flask_thread = Thread(target=run_flask_app)
    flask_thread.daemon = True
    flask_thread.start()

    # Jalankan listener websocket di thread utama
    try:
        asyncio.run(liquidation_listener())
    except KeyboardInterrupt:
        logging.info("Bot dihentikan manual.")
